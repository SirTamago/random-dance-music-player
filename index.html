<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RDP Pro v6 (Mix Export)</title>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- WaveSurfer 7 + Regions -->
    <script src="https://unpkg.com/wavesurfer.js@7"></script>
    <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/regions.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        body { background-color: #000; color: #fff; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        .spotify-green { color: #1DB954; }
        .bg-spotify-green { background-color: #1DB954; }

        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .modal { transition: opacity 0.2s ease; }

        /* 导出容器：不再完全移出屏幕，而是利用层级隐藏，保证渲染引擎能捕获 */
        #export-wrapper {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            z-index: -50;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
            height: 0;
        }
        #export-canvas {
            width: 800px;
            background-color: #080808;
            padding: 60px;
            box-sizing: border-box;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            margin: 0 auto;
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden bg-black text-white">

<!-- 1. 顶部栏 -->
<header class="h-14 flex justify-between items-center px-4 bg-zinc-900 border-b border-zinc-800 z-20">
    <h1 class="text-base font-bold flex items-center gap-2">
        <i class="fa-solid fa-sliders spotify-green"></i> RDP <span class="text-[10px] bg-zinc-700 px-1 rounded text-gray-300">v6</span>
    </h1>
    <div class="flex gap-2">
        <!-- 隐藏的文件输入框 -->
        <input type="file" id="config-input" accept=".json" class="hidden" onchange="loadConfigFromFile(this.files[0])">
        <input type="file" id="custom-beep-input" accept="audio/*" class="hidden" onchange="loadCustomBeep(this.files[0])">
        
        <button onclick="openImportModal()" class="text-xs bg-zinc-800 border border-zinc-700 px-3 py-1 rounded hover:bg-zinc-700 transition"><i class="fa-solid fa-file-import"></i> 导入</button>
        <button onclick="saveConfig()" class="text-xs bg-zinc-800 border border-zinc-700 px-3 py-1 rounded hover:bg-zinc-700 transition"><i class="fa-solid fa-floppy-disk"></i> 保存</button>
        <button onclick="exportImage()" class="text-xs bg-zinc-800 border border-zinc-700 px-3 py-1 rounded hover:bg-zinc-700 transition"><i class="fa-solid fa-image"></i> 图片</button>
    </div>
</header>

<!-- 2. 主列表 -->
<main class="flex-1 overflow-y-auto no-scrollbar relative bg-black" id="main-area">
    <div id="empty-state" class="flex flex-col items-center justify-center h-full text-gray-500">
        <div class="w-16 h-16 bg-zinc-800 rounded-full flex items-center justify-center mb-4">
            <i class="fa-solid fa-music text-3xl text-zinc-600"></i>
        </div>
        <p class="text-sm text-gray-400 mb-6">MP3 / AAC / JSON Config</p>
        <div class="flex gap-3">
             <label class="bg-white text-black font-bold py-2 px-6 rounded-full cursor-pointer hover:scale-105 transition transform text-sm">
                添加歌曲
                <input type="file" multiple accept="audio/*" class="hidden" onchange="handleFiles(this.files)">
            </label>
            <button onclick="openImportModal()" class="bg-zinc-800 text-white font-bold py-2 px-6 rounded-full hover:bg-zinc-700 transition transform text-sm">
                导入配置
            </button>
        </div>
    </div>

    <div id="song-list-container" class="hidden pb-32 pt-2">
        <div class="flex justify-between items-center px-4 mb-2">
            <span class="text-zinc-500 text-[10px] font-bold uppercase tracking-widest" id="list-title">Setlist</span>
            <div class="flex gap-4">
                 <button onclick="forceDownloadCheck()" class="text-[10px] font-bold text-gray-400 hover:text-white uppercase"><i class="fa-solid fa-cloud-arrow-down"></i> Cache Check</button>
                 <label class="text-spotify-green text-[10px] font-bold cursor-pointer hover:underline">
                    + ADD MORE
                    <input type="file" multiple accept="audio/*" class="hidden" onchange="handleFiles(this.files)">
                </label>
            </div>
        </div>
        <ul id="song-list" class="space-y-0.5 px-2"></ul>
    </div>
</main>

<!-- 3. 底部播放条 -->
<footer class="h-20 bg-zinc-900 border-t border-zinc-800 flex items-center px-4 justify-between z-30 fixed bottom-0 w-full">
    <div class="flex items-center w-[30%] overflow-hidden">
        <div class="flex flex-col overflow-hidden justify-center">
            <span id="player-title" class="text-sm font-bold truncate text-white">Ready</span>
            <span id="player-status" class="text-[10px] text-gray-400 truncate">--</span>
        </div>
    </div>

    <div class="flex flex-col items-center w-[40%]">
        <div class="flex items-center gap-6 mb-1">
            <button onclick="playPrev()" class="text-gray-400 hover:text-white disabled:opacity-30" id="btn-prev" disabled><i class="fa-solid fa-backward-step text-lg"></i></button>
            <button onclick="toggleMainPlay()" id="btn-play" class="w-9 h-9 bg-white rounded-full flex items-center justify-center hover:scale-105 transition text-black disabled:opacity-50" disabled><i class="fa-solid fa-play"></i></button>
            <button onclick="playNext()" class="text-gray-400 hover:text-white disabled:opacity-30" id="btn-next" disabled><i class="fa-solid fa-forward-step text-lg"></i></button>
        </div>
        <div class="w-full flex items-center gap-2 text-[9px] text-gray-500 font-mono">
            <span id="time-display">00:00</span>
            <div class="flex-1 h-1 bg-zinc-700 rounded-full overflow-hidden relative">
                <div id="progress-bar" class="h-full bg-spotify-green w-0 transition-all duration-300"></div>
            </div>
        </div>
    </div>

    <div class="flex items-center justify-end w-[30%] gap-2">
        <!-- 随机模式按钮组 -->
        <div id="random-controls" class="flex gap-2">
            <button onclick="prepareRandomMode()" id="btn-mode-random" class="text-[10px] font-bold px-3 py-1.5 rounded-full bg-zinc-800 text-gray-300 hover:text-white border border-zinc-700">RANDOM</button>
            
            <!-- 混音导出按钮 -->
            <button onclick="startMixExport()" id="btn-export-audio" class="hidden text-[10px] font-bold px-3 py-1.5 rounded-full bg-indigo-900/40 text-indigo-300 border border-indigo-800 hover:bg-indigo-800 hover:text-white transition">
                <i class="fa-solid fa-file-audio mr-1"></i> MIX
            </button>
            
            <button onclick="stopAll()" id="btn-stop" class="hidden text-[10px] font-bold px-3 py-1.5 rounded-full bg-red-900/40 text-red-400 border border-red-900 hover:bg-red-800 hover:text-white transition">EXIT</button>
        </div>
    </div>
</footer>

<!-- 4. Au风格全览编辑器 -->
<div id="editor-modal" class="fixed inset-0 bg-black/95 z-50 hidden flex flex-col opacity-0 modal">
    <div class="h-12 px-4 flex justify-between items-center bg-zinc-900 border-b border-zinc-800">
        <span class="text-xs font-bold text-gray-300">Waveform Editor</span>
        <button onclick="closeEditor()" class="text-gray-400 hover:text-white"><i class="fa-solid fa-xmark text-lg"></i></button>
    </div>
    <div class="flex-1 flex flex-col px-4 justify-center relative">
        <h3 id="editor-title" class="text-center text-lg font-bold mb-8 text-white truncate">Song Title</h3>
        <div class="relative w-full h-48 bg-zinc-900 rounded-lg border border-zinc-700 overflow-hidden shadow-2xl">
            <div id="waveform-full" class="w-full h-full"></div>
            <div id="editor-loading" class="absolute inset-0 flex items-center justify-center text-xs text-gray-500 hidden z-10 bg-black/50">
                <i class="fa-solid fa-spinner fa-spin mr-2"></i> Loading Audio...
            </div>
        </div>
        <div class="flex justify-between mt-2 text-[10px] text-gray-500 font-mono">
            <span>00:00</span>
            <span class="text-center flex-1"><i class="fa-solid fa-hand-pointer mr-1"></i> 点击波形听歌 / 拖动绿色方块选区</span>
            <span id="editor-total-duration">--:--</span>
        </div>
        <div class="flex justify-center gap-6 mt-8 text-xs font-mono">
            <div class="bg-zinc-800 px-4 py-3 rounded text-gray-300 flex flex-col items-center min-w-[120px]">
                <span class="text-[10px] text-zinc-500 uppercase tracking-widest mb-1">Start Time</span>
                <span id="region-start" class="text-white font-bold text-lg">00:00.00</span>
            </div>
            <div class="bg-zinc-800 px-4 py-3 rounded text-gray-300 flex flex-col items-center min-w-[120px]">
                <span class="text-[10px] text-zinc-500 uppercase tracking-widest mb-1">Duration</span>
                <span id="region-duration" class="text-spotify-green font-bold text-lg">00:00.00</span>
            </div>
        </div>
    </div>
    <div class="p-6 bg-zinc-900 border-t border-zinc-800 flex justify-between items-center">
        <div class="flex gap-4">
            <button id="editor-play-btn" onclick="toggleEditorPlay()" class="w-10 h-10 rounded-full bg-zinc-700 hover:bg-zinc-600 flex items-center justify-center text-white transition"><i class="fa-solid fa-play"></i></button>
            <button onclick="previewRegion()" class="px-5 h-10 rounded-full bg-zinc-800 hover:bg-zinc-700 text-xs font-bold text-spotify-green border border-zinc-700 transition"><i class="fa-solid fa-rotate-right mr-2"></i> Try Loop</button>
        </div>
        <button onclick="saveEditor()" class="px-8 h-10 bg-white text-black font-bold rounded-full text-xs hover:bg-gray-200">Save & Close</button>
    </div>
</div>

<!-- 5. 倒计时层 -->
<div id="countdown-layer" class="fixed inset-0 bg-black z-[60] hidden flex items-center justify-center flex-col select-none">
    <div id="cnt-num" class="text-[120px] font-black text-spotify-green leading-none">3</div>
    <div class="mt-4 text-xl font-bold text-white flex flex-col items-center">
        <span class="text-zinc-600 text-[10px] uppercase tracking-[0.3em] mb-2">Up Next</span>
        <span id="cnt-next-name" class="text-center px-4">Song Name</span>
    </div>
</div>

<!-- 6. 下载/混音进度弹窗 -->
<div id="download-modal" class="fixed inset-0 bg-black/90 z-[70] hidden flex flex-col items-center justify-center p-8 select-none">
    <i id="process-icon" class="fa-solid fa-cloud-arrow-down text-4xl text-spotify-green mb-6 animate-bounce"></i>
    <h2 id="process-title" class="text-2xl font-bold mb-2">Processing...</h2>
    <p id="process-desc" class="text-gray-400 text-sm mb-8 text-center max-w-md">Please wait.</p>
    
    <div class="w-full max-w-md h-2 bg-zinc-800 rounded-full overflow-hidden mb-2">
        <div id="download-bar" class="h-full bg-spotify-green w-0 transition-all duration-300"></div>
    </div>
    <div class="flex justify-between w-full max-w-md text-xs font-mono text-gray-500 mb-8">
        <span id="download-count">0 / 0</span>
        <span id="download-percent">0%</span>
    </div>
    <div class="text-xs text-red-500 h-4 mb-4" id="download-error"></div>
    <button onclick="cancelDownload()" class="px-6 py-2 rounded-full border border-zinc-600 text-zinc-400 hover:text-white hover:border-white text-xs font-bold transition">CANCEL</button>
</div>

<!-- 7. 导入方式选择弹窗 -->
<div id="import-modal" class="fixed inset-0 bg-black/90 z-[80] hidden flex flex-col items-center justify-center p-6 modal opacity-0">
    <div class="bg-zinc-900 border border-zinc-800 p-8 rounded-xl w-full max-w-md shadow-2xl relative">
        <button onclick="closeImportModal()" class="absolute top-4 right-4 text-gray-500 hover:text-white"><i class="fa-solid fa-xmark text-xl"></i></button>
        
        <h2 class="text-xl font-bold mb-6 flex items-center gap-2"><i class="fa-solid fa-file-import text-spotify-green"></i> Settings & Import</h2>

        <!-- 本地文件 -->
        <div class="mb-6">
            <h3 class="text-xs text-gray-400 uppercase tracking-widest mb-3 font-bold">Import Config</h3>
            <button onclick="document.getElementById('config-input').click(); closeImportModal()" class="w-full py-3 bg-zinc-800 hover:bg-zinc-700 rounded-lg border border-zinc-700 text-sm font-medium transition flex items-center justify-center gap-2 mb-2">
                <i class="fa-solid fa-folder-open"></i> Choose JSON File
            </button>
            <div class="flex gap-2">
                <input type="text" id="import-url-input" placeholder="Or paste JSON URL..." class="flex-1 bg-black border border-zinc-700 rounded px-3 py-2 text-sm focus:border-spotify-green focus:outline-none transition">
                <button onclick="loadConfigFromUrl()" class="bg-spotify-green text-black font-bold px-4 py-2 rounded text-sm hover:scale-105 transition">Load</button>
            </div>
            <p id="url-import-status" class="text-[10px] text-gray-500 mt-2 h-4"></p>
        </div>

        <div class="h-px bg-zinc-800 w-full mb-6"></div>

        <!-- 自定义提示音 -->
        <div>
            <h3 class="text-xs text-gray-400 uppercase tracking-widest mb-3 font-bold">Custom Countdown Sound</h3>
            <div class="flex items-center gap-3">
                <button onclick="document.getElementById('custom-beep-input').click()" class="flex-1 py-2 bg-zinc-800 hover:bg-zinc-700 rounded border border-zinc-700 text-xs font-medium transition">
                    <i class="fa-solid fa-upload"></i> Upload Audio
                </button>
                <button onclick="clearCustomBeep()" class="py-2 px-3 bg-zinc-800 hover:bg-red-900/50 hover:text-red-400 rounded border border-zinc-700 text-xs transition" title="Reset to default">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
            <p id="custom-beep-status" class="text-[10px] text-gray-500 mt-2">Default: Beep + "GO"</p>
        </div>
    </div>
</div>

<!-- 8. 导出图片生成区 -->
<div id="export-wrapper">
    <div id="export-canvas">
        <div class="mb-12">
            <h1 class="text-7xl font-black italic tracking-tighter text-white mb-2">SETLIST</h1>
            <div class="h-1 w-20 bg-spotify-green"></div>
            <p class="text-zinc-500 text-sm mt-4 tracking-[0.2em] uppercase font-bold">Random Dance Play</p>
        </div>
        <ul id="export-list-ul" class="grid grid-cols-1 gap-8"></ul>
        <div class="mt-16 text-right"><span class="text-zinc-700 text-xs uppercase tracking-widest font-bold border border-zinc-800 px-2 py-1 rounded">RDP Generated</span></div>
    </div>
</div>

<script>
    let playlist = [];
    let playQueue = [];
    let currentIndex = -1;
    let isRandomMode = false;
    let isDownloading = false;
    let downloadAbortController = null;
    let customBeepFile = null; // 用户上传的提示音文件

    let audio = new Audio();
    let audioCtx = null;
    let playState = { timerId: null, remainingTime: 0, isPlaying: false };
    let ws = null;
    let wsRegion = null;
    let currentEditId = null;

    // ==========================================
    // 0. 导入与设置管理器
    // ==========================================

    function openImportModal() {
        const m = document.getElementById('import-modal');
        m.classList.remove('hidden');
        setTimeout(()=>m.classList.remove('opacity-0'), 10);
        document.getElementById('import-url-input').focus();
    }

    function closeImportModal() {
        const m = document.getElementById('import-modal');
        m.classList.add('opacity-0');
        setTimeout(()=>m.classList.add('hidden'), 200);
        document.getElementById('url-import-status').innerText = "";
    }

    function loadConfigFromFile(file) {
        if (!file) return;
        const r = new FileReader();
        r.onload = e => parseAndLoadConfig(e.target.result);
        r.readAsText(file);
    }
    
    // 加载自定义Beep
    function loadCustomBeep(file) {
        if (!file) return;
        customBeepFile = file;
        document.getElementById('custom-beep-status').innerText = "Loaded: " + file.name;
        document.getElementById('custom-beep-status').className = "text-[10px] text-spotify-green mt-2";
    }

    function clearCustomBeep() {
        customBeepFile = null;
        document.getElementById('custom-beep-input').value = "";
        document.getElementById('custom-beep-status').innerText = "Default: Beep + \"GO\"";
        document.getElementById('custom-beep-status').className = "text-[10px] text-gray-500 mt-2";
    }

    async function loadConfigFromUrl() {
        const url = document.getElementById('import-url-input').value.trim();
        const status = document.getElementById('url-import-status');
        if (!url) return;

        status.innerText = "Fetching...";
        status.className = "text-[10px] text-yellow-500 mt-2 h-4";

        try {
            const res = await fetch(url);
            if (!res.ok) throw new Error("Network response was not ok");
            const text = await res.text();
            
            status.innerText = "Success!";
            status.className = "text-[10px] text-spotify-green mt-2 h-4";
            
            setTimeout(() => {
                parseAndLoadConfig(text);
                closeImportModal();
                document.getElementById('import-url-input').value = ""; 
            }, 500);

        } catch (e) {
            console.error(e);
            status.innerText = "Error: " + e.message;
            status.className = "text-[10px] text-red-500 mt-2 h-4";
        }
    }

    // ==========================================
    // 修复：更智能的匹配逻辑，且不再乱生成URL
    // ==========================================
    function parseAndLoadConfig(jsonString) {
        try {
            const d = JSON.parse(jsonString);
            
            // 1. 先把当前已有的本地文件整理出来，做一个“文件池”
            // key 使用 "小写 + 去除空格" 的名称，提高匹配率
            const filePool = {};
            playlist.forEach(p => {
                if (p.file) {
                    // 比如 "My Song.mp3" -> "mysong"
                    const simpleName = p.name.toLowerCase().replace(/\s+/g, '');
                    filePool[simpleName] = p.file;
                    // 同时保留原始名字匹配，以防万一
                    filePool[p.name] = p.file;
                }
            });

            // 2. 解析新配置
            playlist = d.songs.map(s => {
                const cleanName = s.name.toLowerCase().replace(/\s+/g, '');
                
                // 尝试从文件池里找文件
                const matchedFile = filePool[cleanName] || filePool[s.name];

                // 处理 URL：只有当 JSON 里明确写了 url 时才保留
                // 如果是 null，就保持 null，绝对不要自动生成 /r2/ 链接
                let finalUrl = s.url || null; 

                return { 
                    ...s, 
                    file: matchedFile || null, // 如果找到文件就挂载，没找到就是 null
                    id: s.id || Math.random().toString(36).substr(2,9),
                    url: finalUrl
                };
            });

            stopAll();
            updateUI();

            // 3. 只有当确实有 URL 且没有本地文件时，才提示下载
            const needsDl = playlist.filter(s => s.url && !s.file);
            
            if (needsDl.length > 0) {
                if (confirm(`Loaded ${playlist.length} songs.\n${needsDl.length} songs have remote URLs. Download cache now?`)) {
                    startDownloadProcess(needsDl);
                }
            } else {
                // 如果没有需要下载的，也提示一下成功
                // 检查是否有缺失文件的情况 (既没文件也没URL)
                const missing = playlist.filter(s => !s.url && !s.file).length;
                if (missing > 0) {
                    alert(`Loaded ${playlist.length} songs.\nNote: ${missing} songs have no audio file (names didn't match). Please drag local files again to fix.`);
                } else {
                    // 完美情况
                    console.log("Config loaded, all files matched.");
                }
            }

        } catch(e) { 
            alert("Invalid JSON Format"); 
            console.error(e);
        }
    }


    // ==========================================
    // 1. 下载管理器
    // ==========================================

    function forceDownloadCheck() {
        const needsDl = playlist.filter(s => s.url && !s.file);
        if (needsDl.length > 0) startDownloadProcess(needsDl);
        else alert("All songs are cached locally or have no URL.");
    }

    async function startDownloadProcess(itemsToDownload) {
        if (isDownloading) return;
        isDownloading = true;
        downloadAbortController = new AbortController();
        const signal = downloadAbortController.signal;

        showProcessModal("Caching Audio...", "Downloading songs to memory.");

        let total = itemsToDownload.length;
        let completed = 0;
        let errors = 0;

        updateProcessBar(0, total);
        const batchSize = 3; 
        
        for (let i = 0; i < total; i += batchSize) {
            if (signal.aborted) break;
            const batch = itemsToDownload.slice(i, i + batchSize);
            const promises = batch.map(song => fetchAndCacheSong(song, signal));
            const results = await Promise.all(promises);
            results.forEach(res => { if (res) completed++; else errors++; });
            updateProcessBar(completed + errors, total);
        }

        isDownloading = false;
        setTimeout(() => {
            hideProcessModal();
            renderList();
            if (errors > 0) alert(`Download finished. ${completed} success, ${errors} failed.`);
        }, 500);
    }

    async function fetchAndCacheSong(song, signal) {
        try {
            const response = await fetch(song.url, { signal });
            if (!response.ok) throw new Error("Net Error");
            const blob = await response.blob();
            song.file = new File([blob], song.name + ".mp3", { type: "audio/mpeg" });
            return true;
        } catch (e) {
            console.error(`Failed to download ${song.name}:`, e);
            return false;
        }
    }

    function cancelDownload() {
        if (downloadAbortController) {
            downloadAbortController.abort();
            isDownloading = false;
            hideProcessModal();
        }
    }

    function showProcessModal(title, desc) {
        const modal = document.getElementById('download-modal');
        document.getElementById('process-title').innerText = title;
        document.getElementById('process-desc').innerText = desc;
        document.getElementById('download-error').innerText = "";
        modal.classList.remove('hidden');
    }

    function hideProcessModal() {
        document.getElementById('download-modal').classList.add('hidden');
    }

    function updateProcessBar(current, total) {
        const pct = total === 0 ? 0 : Math.round(current / total * 100);
        document.getElementById('download-bar').style.width = `${pct}%`;
        document.getElementById('download-count').innerText = `${current} / ${total}`;
        document.getElementById('download-percent').innerText = `${pct}%`;
    }


    // ==========================================
    // 2. 播放控制 (逻辑修改：支持先随机后播放)
    // ==========================================

    function playSong(song) {
        let src = null;
        if (song.file) src = URL.createObjectURL(song.file);
        else if (song.url) src = song.url;

        if (!src) { playNext(); return; }

        audio.src = src;
        audio.currentTime = song.start;
        playState.remainingTime = song.duration;
        playState.isPlaying = true;

        document.getElementById('player-title').innerText = song.name;
        document.getElementById('player-status').innerText = `Playing`;
        document.getElementById('btn-play').innerHTML = '<i class="fa-solid fa-pause"></i>';
        document.getElementById('btn-play').disabled = false;

        audio.play().then(() => startTimerLoop()).catch(e => { console.error(e); playNext(); });
    }

    function startTimerLoop() {
        if (playState.timerId) clearInterval(playState.timerId);
        playState.timerId = setInterval(() => {
            if (audio.paused) return;
            playState.remainingTime--;
            updateProgressUI(playState.remainingTime);
            if (playState.remainingTime <= 0) {
                stopTimerAndAudio();
                playNext();
            }
        }, 1000);
    }

    function toggleMainPlay() {
        // 如果是随机模式且尚未开始（currentIndex == -1），点击播放则开始第一首
        if (isRandomMode && currentIndex === -1 && playQueue.length > 0) {
            playNext();
            return;
        }

        if (!audio.src) return;
        if (playState.isPlaying) {
            audio.pause();
            clearInterval(playState.timerId); 
            playState.isPlaying = false;
            document.getElementById('btn-play').innerHTML = '<i class="fa-solid fa-play"></i>';
            document.getElementById('player-status').innerText = "Paused";
        } else {
            audio.play();
            startTimerLoop(); 
            playState.isPlaying = true;
            document.getElementById('btn-play').innerHTML = '<i class="fa-solid fa-pause"></i>';
            document.getElementById('player-status').innerText = "Playing";
        }
    }

    function updateProgressUI(left) {
        const currentSong = isRandomMode ? playQueue[currentIndex] : playlist[currentIndex];
        if(!currentSong) return;
        const total = currentSong.duration;
        const pct = Math.max(0, ((total - left) / total) * 100);
        document.getElementById('progress-bar').style.width = `${pct}%`;
        document.getElementById('time-display').innerText = `-${left}s`;
    }

    function playNext() { 
        stopTimerAndAudio(); 
        if(isRandomMode) { 
            currentIndex++; 
            if(currentIndex >= playQueue.length){
                alert("Random Play Finished!"); 
                stopAll();
            } else {
                renderList(); // 更新高亮
                startCountdown(playQueue[currentIndex]); 
            }
        } 
    }
    
    function playPrev() { 
        stopTimerAndAudio(); 
        if(isRandomMode && currentIndex > 0) { 
            currentIndex--; 
            renderList();
            startCountdown(playQueue[currentIndex]); 
        } 
    }
    
    function stopTimerAndAudio() { 
        if (playState.timerId) clearInterval(playState.timerId); 
        audio.pause(); 
        playState.isPlaying = false; 
    }

    // ==========================================
    // 3. 随机模式与混音导出 (新增/修改)
    // ==========================================

    // 修改：只准备队列，不立即播放
    function prepareRandomMode() {
        if (playlist.length === 0) return;
        
        // 洗牌
        playQueue = [...playlist].sort(() => Math.random() - 0.5);
        isRandomMode = true; 
        currentIndex = -1; // -1 表示尚未开始

        // UI 变更
        document.getElementById('btn-mode-random').innerText = "RESHUFFLE"; // 变成重新洗牌
        document.getElementById('btn-export-audio').classList.remove('hidden');
        document.getElementById('btn-stop').classList.remove('hidden');
        document.getElementById('btn-prev').disabled = false;
        document.getElementById('btn-next').disabled = false;
        
        document.getElementById('player-title').innerText = "Random Mode Ready";
        document.getElementById('player-status').innerText = "Press Play to Start";
        document.getElementById('btn-play').disabled = false;
        document.getElementById('btn-play').innerHTML = '<i class="fa-solid fa-play"></i>';

        renderList();
    }

    function stopAll() {
        stopTimerAndAudio();
        isRandomMode = false; 
        currentIndex = -1;
        playQueue = [];

        document.getElementById('btn-mode-random').innerText = "RANDOM";
        document.getElementById('btn-mode-random').classList.remove('hidden');
        document.getElementById('btn-export-audio').classList.add('hidden');
        document.getElementById('btn-stop').classList.add('hidden');
        
        document.getElementById('player-title').innerText = "Ready";
        document.getElementById('player-status').innerText = "--";
        document.getElementById('progress-bar').style.width = '0';
        document.getElementById('time-display').innerText = "00:00";
        document.getElementById('btn-play').disabled = true;
        document.getElementById('btn-play').innerHTML = '<i class="fa-solid fa-play"></i>';
        
        updateUI();
    }

    // === 音频混音导出 (核心新功能) ===
    // === 修复后的混音导出函数 ===
    // 3. 修复后的 主导出函数
    async function startMixExport() {
        if (!playQueue.length) return;
        if (!confirm(`Export mix of ${playQueue.length} songs?\nThis will merge them into a single WAV file.`)) return;

        showProcessModal("Exporting Mix...", "Initializing Audio Context...");
        
        try {
            // 1. 初始化离线上下文
            const SAMPLE_RATE = 44100;
            let totalSeconds = 0;
            const GAP = 3.5; 
            playQueue.forEach(s => totalSeconds += (s.duration + GAP));
            
            // 安全限制：防止时长过长导致内存崩溃 (限制在 1小时以内)
            if(totalSeconds > 3600) {
                 alert("Setlist too long for browser export (Max 1 hour).");
                 return hideProcessModal();
            }

            const offlineCtx = new OfflineAudioContext(2, Math.ceil(totalSeconds * SAMPLE_RATE), SAMPLE_RATE);
            
            // 2. 准备倒计时音频 (Beep)
            let beepBuffer = null;
            document.getElementById('process-desc').innerText = "Generating Countdown Audio...";
            
            try {
                if (customBeepFile) {
                    const arrayBuffer = await customBeepFile.arrayBuffer();
                    beepBuffer = await decodeAudioDataSafe(offlineCtx, arrayBuffer);
                } else {
                    // 关键修复：确保在这里 await，拿到真正的 Buffer
                    beepBuffer = await createDefaultBeepBuffer(offlineCtx);
                }
            } catch(e) {
                console.warn("Beep generation failed:", e);
                // 如果生成失败，就不使用提示音，但不阻断流程
                beepBuffer = null; 
            }

            // 3. 逐个处理歌曲
            let currentTime = 0;
            updateProcessBar(0, playQueue.length);

            for (let i = 0; i < playQueue.length; i++) {
                const song = playQueue[i];
                document.getElementById('process-desc').innerText = `Processing: ${song.name}`;
                
                // A. 插入倒计时 (如果有的话)
                if (beepBuffer instanceof AudioBuffer) {
                    const beepSrc = offlineCtx.createBufferSource();
                    beepSrc.buffer = beepBuffer; // 这里现在安全了
                    beepSrc.connect(offlineCtx.destination);
                    beepSrc.start(currentTime);
                    currentTime += beepBuffer.duration;
                } else {
                    currentTime += 3.0; // Fallback gap
                }

                // B. 加载并插入歌曲
                let songBuffer = null;
                try {
                    let fileBlob = song.file;
                    if (!fileBlob && song.url) {
                        const resp = await fetch(song.url);
                        fileBlob = await resp.blob();
                    }
                    
                    if (fileBlob) {
                        const ab = await fileBlob.arrayBuffer();
                        // 使用 safe decoder
                        songBuffer = await decodeAudioDataSafe(offlineCtx, ab);
                    }
                } catch(e) {
                    console.error(`Skipping broken song: ${song.name}`, e);
                }

                if (songBuffer instanceof AudioBuffer) {
                    const songSrc = offlineCtx.createBufferSource();
                    songSrc.buffer = songBuffer;
                    songSrc.connect(offlineCtx.destination);
                    songSrc.start(currentTime, song.start, song.duration);
                    currentTime += song.duration;
                }

                currentTime += 0.5; // 小间隔
                updateProcessBar(i + 1, playQueue.length);
            }

            // 4. 渲染导出
            document.getElementById('process-desc').innerText = "Rendering Final Mix...";
            const renderedBuffer = await offlineCtx.startRendering();

            // 5. 生成 WAV 下载
            document.getElementById('process-desc').innerText = "Encoding WAV...";
            const wavBlob = bufferToWav(renderedBuffer);
            const url = URL.createObjectURL(wavBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `RDP_Mix_${Date.now()}.wav`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            hideProcessModal();

        } catch (e) {
            console.error(e);
            alert("Export Error: " + e.message);
            hideProcessModal();
        }
    }

    // 1. 辅助函数：安全的音频解码（兼容不同浏览器）
    function decodeAudioDataSafe(ctx, arrayBuffer) {
        return new Promise((resolve, reject) => {
            // 复制 ArrayBuffer，防止在某些操作中 buffer 被清空
            const bufferCopy = arrayBuffer.slice(0);
            
            // 尝试使用 Promise 风格 (现代浏览器)
            const res = ctx.decodeAudioData(bufferCopy, 
                (decoded) => resolve(decoded), 
                (err) => reject(err)
            );
            
            // 如果返回值是 Promise (标准规定)，则处理它
            if (res && typeof res.then === 'function') {
                res.then(resolve).catch(reject);
            }
        });
    }
    
    // 2. 修复后的 Beep 生成器 (确保返回 AudioBuffer)
    async function createDefaultBeepBuffer(ctx) {
        const sr = 44100; // 强制使用标准采样率，避免与 OfflineContext 不匹配
        const dur = 3.0;
        const tempCtx = new OfflineAudioContext(1, Math.ceil(sr * dur), sr);
        
        [0, 1, 2].forEach(t => {
            const osc = tempCtx.createOscillator();
            const gain = tempCtx.createGain();
            osc.connect(gain);
            gain.connect(tempCtx.destination);
            
            osc.type = (t === 2) ? 'square' : 'sine';
            osc.frequency.value = (t === 2) ? 1200 : 800;
            
            osc.start(t);
            osc.stop(t + 0.4);
            
            gain.gain.setValueAtTime(0.5, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
        });

        // 关键修复：这里必须 await startRendering
        const buffer = await tempCtx.startRendering();
        return buffer;
    }

    // WAV 编码辅助函数 (标准实现)
    function bufferToWav(abuffer) {
        let numOfChan = abuffer.numberOfChannels,
            length = abuffer.length * numOfChan * 2 + 44,
            buffer = new ArrayBuffer(length),
            view = new DataView(buffer),
            channels = [], i, sample, offset = 0, pos = 0;

        function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
        function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }

        setUint32(0x46464952); // "RIFF"
        setUint32(length - 8); // file length - 8
        setUint32(0x45564157); // "WAVE"

        setUint32(0x20746d66); // "fmt " chunk
        setUint32(16); // length = 16
        setUint16(1); // PCM (uncompressed)
        setUint16(numOfChan);
        setUint32(abuffer.sampleRate);
        setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
        setUint16(numOfChan * 2); // block-align
        setUint16(16); // 16-bit (hardcoded in this loop)

        setUint32(0x61746164); // "data" - chunk
        setUint32(length - pos - 4); // chunk length

        for(i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));

        while(pos < length) {
            for(i = 0; i < numOfChan; i++) {
                sample = Math.max(-1, Math.min(1, channels[i][offset])); 
                sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0; 
                view.setInt16(pos, sample, true); 
                pos += 2;
            }
            offset++; 
        }
        return new Blob([buffer], {type: "audio/wav"});
    }

    // ==========================================
    // 4. 编辑器与基础功能
    // ==========================================

    function openEditor(id) {
        const song = playlist.find(s => s.id === id);
        if (!song) return;
        currentEditId = id;
        const modal = document.getElementById('editor-modal');
        modal.classList.remove('hidden');
        setTimeout(() => modal.classList.remove('opacity-0'), 10);
        document.getElementById('editor-title').innerText = song.name;
        document.getElementById('editor-loading').classList.remove('hidden');
        if (ws) ws.destroy();
        ws = WaveSurfer.create({
            container: '#waveform-full',
            waveColor: '#555',
            progressColor: '#fff', 
            height: 192, 
            barWidth: 2,
            cursorColor: '#1DB954',
            cursorWidth: 1,
            fillParent: true, 
            autoScroll: false, 
            plugins: [ WaveSurfer.Regions.create() ]
        });
        let src = null;
        if (song.file) src = URL.createObjectURL(song.file);
        else if (song.url) src = song.url;
        ws.load(src);
        ws.on('ready', () => {
            document.getElementById('editor-loading').classList.add('hidden');
            document.getElementById('editor-total-duration').innerText = formatTimeSimple(ws.getDuration());
            wsRegion = ws.plugins[0].addRegion({
                start: song.start,
                end: song.start + song.duration,
                color: 'rgba(29, 185, 84, 0.3)', 
                drag: true,
                resize: true
            });
            updateRegionInfo(wsRegion);
        });
        ws.plugins[0].on('region-updated', (region) => { wsRegion = region; updateRegionInfo(region); });
        ws.on('play', () => document.getElementById('editor-play-btn').innerHTML = '<i class="fa-solid fa-pause"></i>');
        ws.on('pause', () => document.getElementById('editor-play-btn').innerHTML = '<i class="fa-solid fa-play"></i>');
    }

    function toggleEditorPlay() { if (ws) ws.playPause(); }
    function previewRegion() { if (ws && wsRegion) wsRegion.play(); }
    function formatTimeDetailed(seconds) {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        const ms = Math.floor((seconds % 1) * 100); 
        return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
    }
    function updateRegionInfo(region) {
        document.getElementById('region-start').innerText = formatTimeDetailed(region.start);
        document.getElementById('region-duration').innerText = formatTimeDetailed(region.end - region.start);
    }
    function saveEditor() {
        const song = playlist.find(s => s.id === currentEditId);
        if (song && wsRegion) {
            song.start = wsRegion.start;
            song.duration = wsRegion.end - wsRegion.start;
            renderList();
            closeEditor();
        }
    }
    function closeEditor() {
        if (ws) ws.pause();
        const modal = document.getElementById('editor-modal');
        modal.classList.add('opacity-0');
        setTimeout(() => { modal.classList.add('hidden'); if (ws) ws.destroy(); ws = null; }, 200);
    }

    // ==========================================
    // 5. 图片导出 (修复渲染失败与长文件名问题)
    // ==========================================

    function exportImage() {
        const listToExport = (isRandomMode && playQueue.length) ? playQueue : playlist;
        if (listToExport.length === 0) return alert("List empty");

        const wrapper = document.getElementById('export-wrapper');
        const container = document.getElementById('export-canvas');
        const ul = document.getElementById('export-list-ul');
        ul.innerHTML = '';
        
        listToExport.forEach((song, i) => {
            let title = song.name; 
            let artist = ""; 
            const separator = " - "; 
            if (title.includes(separator)) { 
                const parts = title.split(separator); title = parts[0]; artist = parts.slice(1).join(separator); 
            } else if (title.includes("-")) { 
                const parts = title.split("-"); 
                if (parts.length > 1) { title = parts[0].trim(); artist = parts.slice(1).join("-").trim(); } 
            }

            const li = document.createElement('li');
            li.className = "flex items-start gap-6 border-b border-zinc-900/50 pb-4";
            // 使用 break-all 和 whitespace-normal 强制换行
            li.innerHTML = `
                <span class="text-3xl font-black text-zinc-700 font-mono w-16 text-right pt-1 flex-shrink-0">${String(i + 1).padStart(2, '0')}</span>
                <div class="flex flex-col min-w-0 flex-1">
                    <span class="text-xl font-bold text-white leading-tight tracking-tight break-words whitespace-normal">${title}</span>
                    ${artist ? `<span class="text-3xl text-zinc-500 font-medium mt-1 tracking-wide break-words whitespace-normal">${artist}</span>` : ''}
                </div>
            `;
            ul.appendChild(li);
        });

        // 临时显示
        wrapper.style.opacity = '1';
        wrapper.style.height = 'auto'; 
        
        // 增加 scale 提高清晰度，增加 windowHeight 确保渲染完整
        // 注意：html2canvas 对过于巨大的画布有限制，如果列表超过100首可能会截断，但这已经是浏览器极限了
        html2canvas(container, { 
            backgroundColor: "#080808", 
            scale: 2, 
            useCORS: true,
            windowWidth: 1000, // 虚拟宽度
        }).then(canvas => {
            // 恢复隐藏
            wrapper.style.opacity = '0';
            wrapper.style.height = '0';
            
            const link = document.createElement('a'); 
            link.download = `RDP_List_${Date.now()}.png`; 
            link.href = canvas.toDataURL(); 
            link.click();
        }).catch(err => {
            alert("Export failed: " + err);
            wrapper.style.opacity = '0';
            wrapper.style.height = '0';
        });
    }

    // ==========================================
    // 6. 其他辅助
    // ==========================================

    function handleFiles(files) {
        if (!files.length) return;
        Array.from(files).forEach(file => {
            // 获取文件名，去掉后缀
            const rawName = file.name.replace(/\.[^/.]+$/, "");
            // 生成简化名：小写、去空格
            const simpleName = rawName.toLowerCase().replace(/\s+/g, '');

            // 尝试寻找匹配的歌曲
            // 1. 名字完全一样
            // 2. 简化名一样
            // 3. 既没有文件也没有URL的“空壳”歌曲
            const existing = playlist.find(s => {
                if (s.file || s.url) return false; // 已经有资源的就不覆盖了
                const sSimple = s.name.toLowerCase().replace(/\s+/g, '');
                return s.name === rawName || sSimple === simpleName;
            });

            if (existing) {
                existing.file = file; // 匹配成功，挂载文件
            } else {
                // 没匹配上，作为新歌添加
                playlist.push({ 
                    id: Math.random().toString(36).substr(2,9), 
                    name: rawName, 
                    file: file, 
                    start: 0, 
                    duration: 30,
                    url: null
                });
            }
        });
        updateUI();
    }

    function saveConfig() {
        if (!playlist.length) return;
        const blob = new Blob([JSON.stringify({songs: playlist.map(s => ({id:s.id, name:s.name, start:s.start, duration:s.duration, url:s.url||null}))})], {type: "application/json"});
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = "rdp_config.json"; a.click();
    }

    function updateUI() {
        const has = playlist.length > 0;
        document.getElementById('empty-state').classList.toggle('hidden', has);
        document.getElementById('song-list-container').classList.toggle('hidden', !has);
        document.getElementById('btn-play').disabled = !has && !isRandomMode;
        renderList();
    }

    function renderList() {
        // 如果是随机模式，显示随机队列，否则显示主列表
        const list = isRandomMode ? playQueue : playlist;
        const ul = document.getElementById('song-list');
        ul.innerHTML = '';
        
        if (isRandomMode) {
            document.getElementById('list-title').innerText = "RANDOM QUEUE";
            document.getElementById('list-title').className = "text-spotify-green text-[10px] font-bold uppercase tracking-widest";
        } else {
            document.getElementById('list-title').innerText = "EDIT SETLIST";
            document.getElementById('list-title').className = "text-zinc-500 text-[10px] font-bold uppercase tracking-widest";
        }

        list.forEach((song, i) => {
            const cur = (isRandomMode && i === currentIndex && currentIndex !== -1);
            const isLocal = !!song.file;
            const statusIcon = isLocal 
                ? '<i class="fa-solid fa-check text-spotify-green" title="Cached Locally"></i>' 
                : '<i class="fa-solid fa-cloud text-gray-500" title="Streamed from URL"></i>';
            const li = document.createElement('li');
            li.className = `flex justify-between p-3 rounded hover:bg-zinc-800 border-l-2 ${cur ? 'bg-zinc-800 border-spotify-green' : 'border-transparent'}`;
            li.innerHTML = `
                    <div class="flex gap-3 overflow-hidden flex-1 cursor-pointer" onclick="!isRandomMode && openEditor('${song.id}')">
                        <span class="text-xs font-mono w-6 text-right ${cur?'text-spotify-green':'text-gray-600'}">${i+1}</span>
                        <div class="flex flex-col overflow-hidden">
                            <span class="text-sm font-medium truncate ${song.file||song.url?'text-white':'text-red-500'}">
                                ${song.name}
                            </span>
                            <div class="flex items-center gap-2">
                                <span class="text-[9px] text-gray-500 font-mono">
                                    ${formatTimeSimple(song.start)} - ${formatTimeSimple(song.start+song.duration)}
                                </span>
                                <span class="text-[9px]">${statusIcon}</span>
                            </div>
                        </div>
                    </div>
                    ${!isRandomMode ? `<div class="flex gap-3 text-gray-400"><button onclick="openEditor('${song.id}')"><i class="fa-solid fa-pen"></i></button><button onclick="removeSong('${song.id}')"><i class="fa-solid fa-trash"></i></button></div>` : ''}
                `;
            ul.appendChild(li);
        });
    }

    function removeSong(id) { playlist = playlist.filter(s => s.id !== id); updateUI(); }

    function startCountdown(song) {
        if (!customBeepFile) {
            // 使用合成音
            const l = document.getElementById('countdown-layer');
            const n = document.getElementById('cnt-num');
            document.getElementById('cnt-next-name').innerText = song.name;
            l.classList.remove('hidden');
            let c = 3; n.innerText = c; playBeep(800, 0.1);
            const t = setInterval(() => {
                c--;
                if (c>0) { n.innerText = c; playBeep(800, 0.1); }
                else if (c===0) { n.innerText = "GO!"; playBeep(1200, 0.4, 'square'); }
                else { clearInterval(t); l.classList.add('hidden'); playSong(song); }
            }, 1000);
        } else {
            // 使用自定义音频，不显示全屏倒计时层，而是直接播放过渡音频然后切歌
            // 或者：显示倒计时层但不发声，让音频发声？
            // 简单起见：显示倒计时层，播放音频文件，音频播完开始放歌
            const l = document.getElementById('countdown-layer');
            const n = document.getElementById('cnt-num');
            n.innerText = "NEXT";
            document.getElementById('cnt-next-name').innerText = song.name;
            l.classList.remove('hidden');

            const beepAudio = new Audio(URL.createObjectURL(customBeepFile));
            beepAudio.play();
            beepAudio.onended = () => {
                l.classList.add('hidden');
                playSong(song);
            };
            // 安全网：如果音频坏了，5秒后强制切
            setTimeout(() => {
                if(!beepAudio.ended && !audio.paused) { 
                    /* audio playing meaning song started? no. */
                }
            }, 8000);
        }
    }

    function playBeep(f,d,t='sine'){
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const o=audioCtx.createOscillator();
        const g=audioCtx.createGain();
        o.type=t;
        o.frequency.value=f;
        o.connect(g);
        g.connect(audioCtx.destination);
        o.start();
        g.gain.exponentialRampToValueAtTime(0.00001,audioCtx.currentTime+d);
        o.stop(audioCtx.currentTime+d);
    }

    function formatTimeSimple(s) { 
        if (isNaN(s)) return "0:00";
        return Math.floor(s/60)+':'+Math.floor(s%60).toString().padStart(2,'0'); 
    }
</script>
</body>
</html>
